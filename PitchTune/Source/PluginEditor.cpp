/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Utility.h"
#include "PitchProcessor.h"
#include "Psola.h"

using namespace std;
//==============================================================================
PitchTuneAudioProcessorEditor::PitchTuneAudioProcessorEditor (PitchTuneAudioProcessor* ownerFilter)
    : AudioProcessorEditor (ownerFilter)
{
    addAndMakeVisible(transferBtn = new TextButton("transfer"));
    transferBtn->setColour(TextButton::buttonColourId, Colours::white);
    transferBtn->addListener(this);
    transferBtn->setConnectedEdges(Button::ConnectedOnLeft|Button::ConnectedOnRight|Button::ConnectedOnTop|Button::ConnectedOnBottom);

    thumb = NULL;
    numThumbs = 0;
    ppq = 0;
    updateThumb = false;
    type = -1;
    // This is where our plugin's editor size is set.
    setSize (1000, 800);
}

PitchTuneAudioProcessorEditor::~PitchTuneAudioProcessorEditor()
{
    if (thumb) {
        delete [] thumb;
        numThumbs = 0;
    }
    deleteAllChildren();
}

#define MID_MIDI 55
#define NOTE_HEIGHT 30

//==============================================================================
void PitchTuneAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colour(0xFFEFFFF0));
    for (int i = 0; i < 20; ++i) {
        g.setColour(Colour(0xFFB27844));
        int y1 = 0;
        if (i < 11) {
            y1 = 400 - NOTE_HEIGHT * i;
            g.drawLine(0, y1, 1000, y1);
        }
        int y2 = 400 + NOTE_HEIGHT * i;
        g.drawLine(0, y2, 1000, y2);
        
        g.setColour(Colour(0xFF6EFF77));
        if (i < 11) {
            g.drawText(String(MID_MIDI + i), 2, y1 + 6, 20, 20, Justification::left, true);
        }
        g.drawText(String(MID_MIDI - i), 2, y2 + 6, 20, 20, Justification::left, true);
    }
    if (thumb) {
        for (int i = 0; i < numThumbs; ++i) {
            thumb[i].repaint();
        }
    }
    //draw ppq line
#define SAMPLES_PER_DRAWN_SAMPLE    256
    int x = 10 + ppq / Utility::numBeatsPerSample / SAMPLES_PER_DRAWN_SAMPLE;
    g.drawLine(x, 0, x, 800);
}

void PitchTuneAudioProcessorEditor::setThumbs(float *x, long numSamples, PitchProcessor *pp)
{
    vector<int>& cents = pp->psola->getCentDiviations();
    vector<int>& midis = pp->psola->getMidiNums();
    vector<int>& borders = pp->psola->getPitchBorders();
    int nonzero = 0;
    for (int i = 0; i < midis.size(); ++i) {
        if (midis[i] != 0 && midis[i] < 66 && midis[i] > 32) {
            ++nonzero;
        }
    }
    if (thumb) {
        delete [] thumb;
        thumb = NULL;
        numThumbs = 0;
    }
    float max = 0.0;
    for (int i = 0; i < numSamples; ++i) {
        if (fabsf(x[i]) >= max)
            max = fabsf(x[i]);
    }
    
    thumb = new AudioRoll[nonzero];
    for (int i = 0; i < nonzero; ++i) {
        if (midis[i] != 0 && midis[i] < 66 && midis[i] > 32) {
            int startSample = (i == 0) ? 0 : borders[i-1] + 1;
            int endSample = borders[i];
            int length = endSample - startSample + 1;
            thumb[i].setSamples(x, length, midis[i], cents[i], startSample, endSample, max, i);
            
            pitches.push_back(0);
        }
    }
    numThumbs = nonzero;
    for (int i = 0; i < midis.size(); ++i) {
        cout << "borders: " << borders[i] << endl;
        cout << "midi: "<< midis[i] << endl;
        cout << "cent: "<< cents[i] << endl;
    }
    
}

void PitchTuneAudioProcessorEditor::handleAsyncUpdate()
{
    if (updateThumb) {
        if (thumb) {
            for (int i = 0; i < numThumbs; ++i) {
                addAndMakeVisible(&thumb[i]);
                //50 means midi note 50
                int drift = thumb[i].cent / 100.0 * NOTE_HEIGHT;
                thumb[i].setBounds(10 + thumb[i].startDecimatedSample, 400 + NOTE_HEIGHT * (MID_MIDI - thumb[i].midi) - drift, thumb[i].numSamples, NOTE_HEIGHT);
                thumb[i].repaint();
            }
            
        }
        updateThumb = false;
    }
    else if (type == 1) {
        repaint();
    }
    
    type = -1;
}

void PitchTuneAudioProcessorEditor::updateAudio(int index)
{
    if (index < (int)pitches.size())
        pitches[index] = thumb[index].deltaCents;
    
    PitchTuneAudioProcessor *p = getProcessor();
    p->updateAudio(pitches);
}

void PitchTuneAudioProcessorEditor::buttonClicked(Button *theButton)
{
    PitchTuneAudioProcessor *processor = getProcessor();
    if (!processor->isTransferring()) {
        processor->startTransferring();
        transferBtn->setColour(TextButton::buttonColourId, Colours::grey);
    }
//    else {
//        processor->stopTransferring();
//        transferBtn->setColour(TextButton::buttonColourId, Colours::white);
//    }
}

void PitchTuneAudioProcessorEditor::resized()
{
    transferBtn->setBounds(20, 40, 100, 40);
}
